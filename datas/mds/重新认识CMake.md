Visual Studio这个宇宙最强IDE，在我刚刚学C++时就是用的这个，但是由于它的资源占用对我电脑不太友好，所以后来写C++都是DevC++、Visual Studio Code。现在写的这个异想天开的项目比较大，VS的代码提示也舒服，用了VS。

在用VS Code写C++的时候我用了个东西叫CMake，因此，我一直认为CMake是拿来组织编译C++的。

遇到一些问题总是去Github找点库，我用的库大多是一些只有头文件或者是直接拖项目里就能用的。

但是，我用的可不止这种小的库，大型的库也要用到，这些大型的库很大一部分都用了CMake， 难道歪果仁都喜欢拿CMake写C++？

经过长达好几年的知识沉淀，我已经知道静态库啦动态库啦是什么了，这种大型的库肯定不能是拖项目里用的，就算拖进去能编译成功，这不得调试一次等半个小时嘛。于是，我要看一下这些大型的库应该咋用。

## 静态库和动态库

静态库 .lib文件，动态库 .dll文件。

之前拿QT调用过VS编译的dll文件，成功了一半，利用windows的API加载Dll，结果字符串总是传不过去，应该还是什么编译参数没协调好，这是动态库的一种使用方法，这种方法只需要一个dll文件，这个dll导出的函数什么的可以用工具查看。用动态库效率肯定不如静态库啊，还容易被破解，对我来说感觉Dll就一个用途就是做主程序的插件。

.lib文件需要头文件才能用，头文件里写了声明，静态库里写了定义，静态库大概就相当于个cpp文件吧，所以它也会和项目里的东西重定义的。它会在程序编译之后，链接的时候被使用，和程序链接到一起。它与直接往项目里塞cpp文件的区别应该就是编译速度了吧，静态库已经是编译过的了，所以只需要与程序链接。
VS中设置要链接的静态库的话是在项目设置链接器的输入里。

无论是静态库还是动态库都是分架构的。x86啦，x64啦，arm啦。
为了让库可调试，并且编译发布程序的时候保证效率，库还要分调试版本和发行版本。

对我写的项目来说每个库需要编译4次：win32 debug、win32 release、x64 debug、x64 release。

## CMake Make吧！

这些库拿过来根目录有makefile文件，所以可以直接make。

```
cmake .
```

在根目录里输入这个命令，开始make了...

make结束了。

他居然都不问我要make什么，要静态库还是动态库，什么架构...

处了根目录多了一些文件，dll lib exe什么的啥都没造出来！？

## 正确用法

我好像看到了 .sln文件 （VS的解决方案文件）。

所以Cmake编译的事情啥都没做，而是整理文件做成VS的项目，让VS去编译。

但是刚才make到了根目录里，很乱，所以：

```
md build
cd build
cmake ..
```

这样，大工告成，再拿VS编译就好了。

但是用VS打开里面就只有一个x64架构，可能因为我电脑是x64，默认x64，可以用VS再加一个win32进来，调一调输出目录，其余不用动，静态库貌似还需要调一调目标计算机架构。

但是，我没这么勤奋，我想让cmake把win32的给我造出来。

`cmake --help` 告诉我要用 `-G` 设置生成器，用 `-A` 设置架构。
于是，这样make就好了:

```
cmake -G "Visual Studio 16 2019" -A win32
```

不要问我我咋知道我是用的 `"Visual Studio 16 2019"`这东西，`cmake --help`说的，里面支持的东西还不少呢...。

这样有win32了，但是我怎么填他都不会把 win32 和 x64 同时造出来... ~~算了，这样开两个项目还能同时编译呢~~

----

这样会用CMake了，找库再也不用担心拿来不会用了！

